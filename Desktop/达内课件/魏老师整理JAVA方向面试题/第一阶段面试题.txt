# 第一阶段面试题

## 一、JAVA基础

### 1. 列出JAVA中所有基本数据类型，并说明这些数据类型占用的字节数？？

答案：

java的原始数据类型，也可以叫java的基本数据类型，一共就8个，分别是：byte、short、int、long、boolean、char、float、double

byte 1个字节

boolean 1个字节

char 2个字节

short 2个字节

int 4个字节

long 8个字节

float 4个字节

double 8个字节

### 2.continue和 break有什么区别？

答案：

break和continue都是用来控制循环结构的。

1. break：提前终止循环可以使用break来完成。break完全结束一个循环，跳出循环体执行循环后面的语句。
2. continue：理解为continue是跳过当次循环中剩下的语句，执行下一次循环。
3. 区别：continue只终止本次循环，break则完全终止循环

### 3.i++和++i的区别？

1. i++ 理解为：先用i值后加1, 比如int j=i++; 如果i的初值是1，那么表达式i++的整体值就是1，然后，i的值就变成了2，最后执行赋值运算，将i++整体的值1，赋值给j，j为1。
2. ++i 理解为：先加1后用i值，比如int j=++i;如果i的初值是1，首先i增加1为2，然后用i的值2最为++i整体表达式的值，最后进行赋值运算，将++i表达式的值2赋值给j，j为2。

> 注意：这两个表达式在计算时，=号赋值计算，都是最后发生的，是非常常见的考点。

## 二、OOP

### 1.面向对象的特征有哪些方面？

答案：三大特性是：封装,继承,多态

1. 所谓封装，也就是把客观事物抽象封装成类。封装是面向对象的特征之一。 
	1. 简单的说，一个类就是一个封装了数据以及操作这些数据的算法。
	2. 对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
2. 所谓继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法。
	1. 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。
	2. 子类是对父类功能的扩展
	3. 实际开发中父类往往是从子类泛化而来，父类中的属性和方法是从子类中抽象来的。
3. 所谓多态就是指一个父类具体子类实例的相同方法执行出不同表现。
	1. 多态机制使具有不同对象可以共享相同的外部接口方法。
	2. 这意味着，可以通过相同的方式调用具体对象功能不同方法。


### 2.静态变量和实例变量的区别？

答案：

1. 在语法定义上的区别：
	- 静态变量前要加static 关键字，而实例变量前则不加。
1. 在程序运行时的区别：
	1. 实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。
	2. 静态变量不属于某个实例对象，而是属于类，所以也称为类变量。
	3. 实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

### 3.Overload(重载)和Override(重写)的区别？

答案：

1. 重写必须继承，重载不用。
2. 重写的方法名，参数数目相同，参数类型兼容，重载的方法名相同，参数列表不同。
3. 重写的方法修饰符大于等于父类的方法，重载和修饰符无关。
4. 重写不可以抛出父类没有抛出的一般异常，可以抛出运行时异常

### 4.多态的表现形式有哪些?

答案：重写和重载。向上造型

### 5.abstract class和interface有什么区别?

答案：

1. 含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。
2. abstract class类中定义抽象方法必须在具体子类中实现。
2. 如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。
3. 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。

### 6.接口是否可以继承接口？抽象类是否可以实现（implements）接口？ 抽象类是否可以继承具体类？

答案：

1. 接口可以继承接口，可以继承多个接口
2. 抽象类可以实现接口，可以实现多个接口
3. 抽象类可以继承具体类，但只能继承一个类

### 8.GC是什么?GC的作用

答案：

1. GC是垃圾收集的意思 
2. Java提供的GC功能可以自动监测回收不被引用的对象，释放其占用的内存，
3. 垃圾收集器会自动进行管理。
4. 如果要请求垃圾收集，可以调用下面的方法之一：System.gc()或Runtime.getRuntime().gc()，这些方法会通知GC尽快进行内存垃圾回收。
5. 在对象使用以后要及时释放其引用，有利于垃圾回收，可以有效的防止内存泄露。

## 三、JAVASE

### 1.说出ArrayList,LinkedList的储存性能和特性？

答案：

1. ArrayList 采用的是数组形式来保存对象的，这种方式将对象放在连续的位置中，优点是索引读取快，从最后插入和删除元素速度快，但是头部插入和删除慢。
2. LinkedList使用双向循环链表方式存储数据,所以头尾插入或读取插入的速度快，而中部插入和读取慢.

### 2.HashMap 和 Hashtable 的区别

答案：

1. 历史原因:Hashtable 是陈旧API，HashMap 是Java 1.2 引进的Map 接口的一个实现
2. 同步性:Hashtable 是线程安全的，也就是说是同步的，而HashMap 是线程序不安全的，不是同步的。由于同步检查所以Hashtable性能稍慢。
3. 值：HashMap 可以插入一个null的key-value

### 3.List、Map、Set三个接口，存取元素时，各有什么特点？

答案：

1. List特点：元素有顺序，元素可重复
2. Set特点：元素无顺序，元素不可重复（注意：元素虽然无顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）
3. Map特点：元素按键值对存储，无顺序

### 4.队列和栈是什么，列出它们的区别？

答案：

1. 队列（Queue）是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。
2. 栈（Stack）是限定只能在表的一端进行插入和删除操作的线性表。
3. 队列先进先出（FIFO），栈先进后出（FILO）。

### 5.String与StringBuffer的区别，StringBuffer和StringBuilder的区别是什么？

答案：

1. String是不可变的，StringBuffer是可变的；StringBuffer是线程安全的，StringBuilder是非线程安全的。
2. 由于字符串链接会自动创建StringBuilder对象，为了避免复杂字符串拼接时候大量创建StringBuilder对象，可以利用StringBuilder优化字符串链接操作。
4. StringBuilder是jdk5之后新增的，其用法与StringBuffer完全一致，但它是线程不安全的，在单线程中最佳，因为其不需要维护线程的安全，因此是最快的。

标签： String StringBuffer StringBuilder

###6.String类能不能被继承，为什么？

答案：

不能被继承，因为String类是final类，final修饰的类是不能被继承

### 8.“==”和“equals”的区别

答案：

1. `==`是值比较，对于引用类型变量`==`是判断引用的值是否是同一个对象地址值，如果是相同对象其内容也一定是相同的
2. equals方法判断的是对象的内容是否相同，由于其默认方法采用的`==`进行引用比较，所以需要重写为按照对象内容比较是否相同。

### 9.HashSet 和 HashMap 区别？

答案：

1. HashMap ：实现Map接口；使用hash算法，里面的数据是无序的；并且存储的是键值对；
2. HashSet ：实现了Set接口；内部封装了HashMap，故也是无序的；HashSet本质就是HashMap，数据存储到HashSet的Key部分，Value部分被屏蔽不使用了。

### 10.描述栈，队列中元素的出入顺序。

答案：

1. 栈的数据结构是，先进后出（FILO），也可以说是后进先出
2. 队列的数据结构是，先进先出（FIFO）

### 11.Comparable和Comparator接口是干什么的？列出它们的区别。

答案：

1. Comparable接口
	1. 实现Comparable接口类表示这个类型的对象可以进行比较大小的。 这种可以比较大小的对象可以进行自然排序。
2. Comparator接口
	1. 比较器用于实现对象任意属性进行比较大小。 
	2. 在排序时候可以通过指定属性比较器实现任意属性排序。
3. 在排序时候Comparable接口用于进行自然排序，而Comparator接口进行自定义排序，自定义排序更加灵活方便而常用。
4. 设计上Comparable不推荐使用，因为对程序本身具有侵入性。

### 12.Java中异常处理机制？

答案：

1. Java异常是一个消息传播机制，如果不被处理将继续传播并且打断当前程序的执行。
2. Java使用面向对象的方式来传播异常消息，发生的每个异常被封装到一个异常对象，该对象中包含有异常的信息。
3. Java中使用try catch finally 语法捕获处理异常消息。

###13.创建线程有几种不同的方式？

答案：

在应用开发中有三种方式可以用来创建线程：

1. 继承Thread类，并且创建对象。
2. 实现Runnable接口，将Runnable接口的具体对象作为参数创建Thread对象。
3. 另外也可以使用Executer创建并重用线程

###14.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?

答案：

可以进入其他非synchronized的方法，synchronized的方法不可以的！

1. Java中的每个对象都有一个锁（lock）或者叫做监视器（monitor）
2. 当一个线程访问对象的synchronized方法时，将在对象上锁，方法不能并发执行。
3. 此时其他任何线程都得阻塞等待到当前线程方法执行结束后，才能有机会执行方法。
4. 也就是说线程排到一个接着一个执行 synchronized的方法。


### 16.请描述TCP。

答案：

TCP是传送控制协议

1. 是面向连接的可靠数据传输协议，TCP会确保数据会可靠的传输到对方.
2. 使用步骤：先建立可靠连接---利用连接中的双向通讯流传输数据-----通讯结束以后，需要关闭连接.
3. java利用Socket和ServerSocketAPI封装了TCP通讯过程，利用这两个类即可实现TCP通讯。
4. HTTP通讯的底层是TCP协议。

### 17.java中多线程是什么？

答案：

1. Java中并发运行多个流程的能力。每一个流程称为一个线程。
2. Java的Thread API封装了线程控制过程。
3. 创建线程对象后调用start方法就可以将线程提交到操作系统执行。
4. 线程最终是由操作系统调度执行的。

### 18.线程进程的基本概念、线程的基本状态以及状态之间的关系

答案：

1. 一个线程是进程的一个顺序执行流程。一个进程中的全部线程共享同一个堆空间。线程本身有一个供程序执行时的栈，一个进程中可以包含多个线程。
2. 新建、就绪、运行状态、阻塞状态、死亡状态
3. 新建状态：利用NEW运算创建了线程对象，此时线程状态为新建状态，调用了新建状态线程的start()方法，将线程提交给操作系统，准备执行，线程将进入到就绪状态。 
4. 就绪状态：由操作系统调度的一个线程，没有被系统分配到处理器上执行，一旦处理器有空闲，操作系统会将它放入处理器中执行，此时线程从就绪状态切换到运行时状态。
5. 运行状态：线程正在运行的过程中，碰到调用Sleep()方法，或者等待IO完成，或等待其他同步方法完成时，线程将会从运行状态，进入到阻塞状态。
6. 死亡状态：线程一旦脱离阻塞状态时，将重新回到就绪状态，重新向下执行，最终进入到死亡状态。一旦线程对象是死亡状态，就只能被GC回收，不能再被调用。

### 19.XML解析技术有哪些？它们的区别是什么？

答案：

常见的有SAX,DOM,DOM4J

2. SAX:SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。
3. DOM:DOM的利用SAX进行读取的，读取以后缓存到内存中成为DOM对象，处理大型文件时内存耗用较高。
4. DOM4J：由于DOM API使用过于繁琐，JAVA的开源组织开发了DOM4J，底层封装了DOM，提供JAVA Bean风格的API，使用非常简洁。

### 20.什么是节点流,什么是过滤流，并且说出常用的节点流和过滤流？

答案：

1. 节点流：有明确的数据源，从数据源读取基础的字节数据，或向数据源写入字节数据。
2. 过滤流：依赖于其他流，不能单独使用，并且都提供了高级功能，使用起来更加方便。
3. FileInputStream FileOutputStram 
4. BufferedInputStream BufferedOutputStream
5. ObjectInputStream ObjectOutputStream

### 21.BufferedReader属于哪种流,它主要是用来做什么的,它里面有那些经典的方法？

答案：

1. BufferedReader只能连接在其他字符流上，所以属于字符流，其底层需要依赖于其他的字符流，或者字节流。
2. BufferedReader提供了字符缓冲功能，能够一定程度上的提升IO性能。
3. 提供了经典的方法readLine()方法，可以从目标流中，读取一行文本。


### 22.字符流和字节流的区别？并且他们的父类叫什么？

答案：

1. JAVA中最基本的流是字节流，任何流的底层都是字节流。
2. 字符流是以字符为单位进行读写的流，大部分的实现类是高级流，其底层一定基于字节流，字符流在字节流基础之上，扩展了字符编码解码功能。
3. 字节流的抽象父类：InputStream OutputStream
4. 字符流的抽象父类：Reader Writer

### 23.什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作？

答案：

1. 对象序列化，将对象中的数据编码为字节序列的过程。
2. 反序列化；将对象的编码字节重新反向解码为对象的过程。
3. JAVA提供了API实现了对象的序列化和反序列化的功能，使用这些API时需要遵守如下约定。
	1. 被序列化的对象类型需要实现序列化接口，此接口是标志接口，没有声明任何的抽象方法，JAVA编译器识别这个接口，自动的为这个类添加序列化和反序列化方法。
	2. 为了保持序列化过程的稳定，建议在类中添加序列化版本号。
	3. 不想让字段放在硬盘上就加transient

### 24.简述HashMap的工作原理？

答案：

1. HashMap是面向查询优化的数据结构，查询性能优异。
2. 在其内部利用数组存储数据。
3. 插入数据时，先根据Key的HashCode计算出数组的下标位置，再利用Key的equals()方法检查是否以存在重复的Key，如果不重复直接存储到数组中，如果重复就作为链表存储到散列桶中。
4. 插入的数据和数组容量的比值大于加载因子则进行数组扩容，并重新散列，默认的加载因子为“0.75”。
5. 查询时，先根据Key的HashCode计算出数组的下标位置，再利用Key的equals()方法检查到Key的位置，如果找到返回Key对应的Value，否则返回Null。
6. 由于利用Key的HashCode直接计算出数据的存储位置，由于直接确定数据的存储位置，相对于其他查找方式，查询效率非常高。

### 25.什么是反射机制？

Java 动态执行机制，可以实现动态执行功能：
 
1. 反射提供了在运行时判断任意一个对象所属的类型，并可以检查解析类型的内部结构。
2. 反射可以动态加载类型，并能够动态创建对象
2. 反射可以动态访问对象的属性。
3. 反射可以动态执行对象的方法。
4. 利用反射API还可以动态的访问，不可见的属性和方法

### 26.哪里用到反射机制？

1. JDBC中，利用反射动态加载了数据库驱动程序。
2. Web服务器中利用反射调用了Sevlet的服务方法。
3. Eclispe等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法。 
4. 很多框架都用到反射机制，注入属性，调用方法，如Hibernate、Struts2、Spring。

### 27.反射机制的优缺点？

1. 优点：可以动态执行！在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。
2. 缺点：对性能有影响，这类操作总是慢于直接执行java代码。
